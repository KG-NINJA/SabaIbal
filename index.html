<!DOCTYPE html>
<html lang="ja">
<head>
  <meta charset="UTF-8" />
  <title>クラフトサバイバル</title>
  <style>
    html, body {
      margin: 0;
      padding: 0;
      height: 100%;
      background: #0f172a;
      color: #f8fafc;
      font-family: "Noto Sans JP", system-ui, sans-serif;
      display: flex;
      align-items: center;
      justify-content: center;
    }

    #ui {
      position: absolute;
      top: 12px;
      left: 50%;
      transform: translateX(-50%);
      width: 920px;
      display: flex;
      justify-content: space-between;
      align-items: center;
      font-size: 14px;
      pointer-events: none;
    }

    #ui section {
      background: rgba(15, 23, 42, 0.6);
      border: 1px solid rgba(148, 163, 184, 0.4);
      border-radius: 8px;
      padding: 8px 12px;
      box-shadow: 0 10px 30px rgba(15, 23, 42, 0.4);
      pointer-events: auto;
    }

    #log {
      position: absolute;
      bottom: 16px;
      left: 50%;
      transform: translateX(-50%);
      width: 920px;
      max-height: 160px;
      overflow-y: auto;
      background: rgba(15, 23, 42, 0.65);
      border: 1px solid rgba(148, 163, 184, 0.3);
      border-radius: 8px;
      padding: 12px;
      box-shadow: 0 10px 30px rgba(15, 23, 42, 0.4);
      font-size: 13px;
      line-height: 1.5;
    }

    canvas {
      border: 4px solid #1e293b;
      border-radius: 12px;
      background: #0b1120;
    }

    strong {
      color: #38bdf8;
    }
  </style>
</head>
<body>
  <div id="ui">
    <section id="status"></section>
    <section id="buildings">
      <strong>建築</strong><br>
      [1] 木の壁 (木2)<br>
      [2] 石の壁 (石2)
    </section>
    <section id="help">
      <strong>操作</strong><br>
      移動: WASD / ←→↑↓<br>
      行動: SPACE (採取/攻撃/建築確定)<br>
      建築モード切替: 1, 2<br>
      昼に素材を集め、夜はモンスターから生き残ろう！
    </section>
  </div>
  <canvas id="game" width="960" height="640"></canvas>
  <div id="log"></div>
  <script>
    const canvas = document.getElementById("game");
    const ctx = canvas.getContext("2d");
    const statusEl = document.getElementById("status");
    const logEl = document.getElementById("log");

    const TILE = 32;
    const COLS = canvas.width / TILE;
    const ROWS = canvas.height / TILE;

    const state = {
      time: 0,
      dayLength: 60,
      nightLength: 35,
      isDay: true,
      player: {
        x: COLS / 2,
        y: ROWS / 2,
        hp: 5,
        maxHp: 5,
        inventory: { wood: 0, stone: 0, food: 0 }
      },
      animals: [],
      monsters: [],
      resources: [],
      buildings: [],
      buildMode: null,
      lastHunt: 0,
      lastAttack: 0,
      lastGather: 0,
      messages: []
    };

    function addMessage(text) {
      state.messages.push({ text, time: Date.now() });
      const p = document.createElement("div");
      p.textContent = text;
      logEl.prepend(p);
      while (logEl.children.length > 12) {
        logEl.removeChild(logEl.lastChild);
      }
    }

    function randomInt(min, max) {
      return Math.floor(Math.random() * (max - min + 1)) + min;
    }

    function spawnResource(type) {
      const margin = 2;
      const resource = {
        type,
        x: randomInt(margin, COLS - margin),
        y: randomInt(margin, ROWS - margin),
        hp: type === "tree" ? 3 : 4
      };
      state.resources.push(resource);
    }

    function spawnAnimal() {
      state.animals.push({
        x: randomInt(2, COLS - 2),
        y: randomInt(2, ROWS - 2),
        dir: Math.random() * Math.PI * 2,
        speed: 0.5,
        hp: 2
      });
    }

    function spawnMonster() {
      const edge = Math.random() < 0.5 ? 0 : COLS - 1;
      const vertical = Math.random() < 0.5;
      const x = vertical ? randomInt(0, COLS - 1) : edge;
      const y = vertical ? edge : randomInt(0, ROWS - 1);
      state.monsters.push({ x, y, speed: 0.6, hp: 3 });
    }

    function initWorld() {
      for (let i = 0; i < 20; i++) spawnResource("tree");
      for (let i = 0; i < 15; i++) spawnResource("rock");
      for (let i = 0; i < 6; i++) spawnAnimal();
      addMessage("朝が始まった。素材を集めて防衛しよう。");
    }

    const keys = new Set();
    document.addEventListener("keydown", (e) => {
      keys.add(e.key.toLowerCase());
      if (e.key === "1") {
        state.buildMode = { type: "woodWall", cost: { wood: 2 } };
        addMessage("建築モード: 木の壁");
      }
      if (e.key === "2") {
        state.buildMode = { type: "stoneWall", cost: { stone: 2 } };
        addMessage("建築モード: 石の壁");
      }
      if (e.key === "Escape") {
        state.buildMode = null;
        addMessage("建築モード解除");
      }
    });
    document.addEventListener("keyup", (e) => keys.delete(e.key.toLowerCase()));

    function update(dt) {
      state.time += dt;
      const cycleLength = state.isDay ? state.dayLength : state.nightLength;
      if (state.time >= cycleLength) {
        state.time = 0;
        state.isDay = !state.isDay;
        if (state.isDay) {
          addMessage("夜を生き延びた！朝になった。素材を集めよう。");
          for (let i = 0; i < 3; i++) spawnAnimal();
          for (let i = 0; i < 5; i++) spawnResource(Math.random() < 0.5 ? "tree" : "rock");
          state.monsters.length = 0;
        } else {
          addMessage("夜が訪れた。モンスターが現れる！");
          for (let i = 0; i < 6; i++) spawnMonster();
        }
      }

      handlePlayerMovement(dt);
      updateAnimals(dt);
      updateMonsters(dt);
    }

    function handlePlayerMovement(dt) {
      const speed = 4 * dt;
      const player = state.player;
      const left = keys.has("a") || keys.has("arrowleft");
      const right = keys.has("d") || keys.has("arrowright");
      const up = keys.has("w") || keys.has("arrowup");
      const down = keys.has("s") || keys.has("arrowdown");

      let nx = player.x;
      let ny = player.y;
      if (left) nx -= speed;
      if (right) nx += speed;
      if (up) ny -= speed;
      if (down) ny += speed;

      nx = Math.max(1, Math.min(COLS - 2, nx));
      ny = Math.max(1, Math.min(ROWS - 2, ny));

      if (!collidesWithBuilding(nx, ny)) {
        player.x = nx;
        player.y = ny;
      }

      if (keys.has(" ") || keys.has("space")) {
        interact();
      }
    }

    function collidesWithBuilding(x, y) {
      return state.buildings.some(b => Math.hypot(b.x - x, b.y - y) < 0.6);
    }

    function interact() {
      const now = performance.now();
      if (state.buildMode) {
        if (now - state.lastGather < 250) return;
        state.lastGather = now;
        if (canAfford(state.buildMode.cost)) {
          payCost(state.buildMode.cost);
          state.buildings.push({
            x: Math.round(state.player.x),
            y: Math.round(state.player.y),
            type: state.buildMode.type,
            hp: state.buildMode.type === "woodWall" ? 8 : 12
          });
          addMessage("壁を建てた！");
        } else {
          addMessage("素材が足りない。");
        }
        return;
      }

      if (now - state.lastGather > 300) {
        state.lastGather = now;
        const target = state.resources.find(r => Math.hypot(r.x - state.player.x, r.y - state.player.y) < 1.2);
        if (target) {
          target.hp--;
          if (target.hp <= 0) {
            if (target.type === "tree") {
              state.player.inventory.wood += 2;
              addMessage("木材を手に入れた！");
            } else {
              state.player.inventory.stone += 2;
              addMessage("石材を手に入れた！");
            }
            state.resources = state.resources.filter(r => r !== target);
          } else {
            addMessage("採取中…");
          }
        }
      }

      if (state.isDay && now - state.lastHunt > 400) {
        state.lastHunt = now;
        const animal = state.animals.find(a => Math.hypot(a.x - state.player.x, a.y - state.player.y) < 1.4);
        if (animal) {
          animal.hp--;
          if (animal.hp <= 0) {
            state.player.inventory.food += 1;
            addMessage("獲物を仕留めた。食料+1");
            state.animals = state.animals.filter(a => a !== animal);
          } else {
            addMessage("攻撃した！");
          }
        }
      }

      if (!state.isDay && now - state.lastAttack > 400) {
        state.lastAttack = now;
        const monster = state.monsters.find(m => Math.hypot(m.x - state.player.x, m.y - state.player.y) < 1.6);
        if (monster) {
          monster.hp -= 2;
          addMessage("モンスターに攻撃！");
          if (monster.hp <= 0) {
            state.monsters = state.monsters.filter(m => m !== monster);
            addMessage("モンスターを倒した！");
          }
        }
      }
    }

    function canAfford(cost) {
      return Object.entries(cost).every(([k, v]) => state.player.inventory[k] >= v);
    }

    function payCost(cost) {
      Object.entries(cost).forEach(([k, v]) => state.player.inventory[k] -= v);
    }

    function updateAnimals(dt) {
      state.animals.forEach(animal => {
        if (Math.random() < 0.02) {
          animal.dir += (Math.random() - 0.5) * 1.5;
        }
        animal.x += Math.cos(animal.dir) * animal.speed;
        animal.y += Math.sin(animal.dir) * animal.speed;
        animal.x = Math.max(1, Math.min(COLS - 2, animal.x));
        animal.y = Math.max(1, Math.min(ROWS - 2, animal.y));
      });

      if (state.animals.length < 4 && state.isDay) {
        if (Math.random() < 0.005) spawnAnimal();
      }
    }

    function updateMonsters(dt) {
      const player = state.player;
      state.monsters.forEach(monster => {
        const dx = player.x - monster.x;
        const dy = player.y - monster.y;
        const dist = Math.hypot(dx, dy);
        const speed = monster.speed * dt * 60;
        if (dist > 0.1) {
          monster.x += (dx / dist) * speed;
          monster.y += (dy / dist) * speed;
        }
        if (dist < 1.1) {
          damagePlayer(1);
          monster.x -= (dx / dist) * 0.4;
          monster.y -= (dy / dist) * 0.4;
        }
      });
    }

    function damagePlayer(amount) {
      state.player.hp = Math.max(0, state.player.hp - amount);
      if (state.player.hp === 0) {
        addMessage("ゲームオーバー… F5で再挑戦！");
      }
    }

    function draw() {
      ctx.clearRect(0, 0, canvas.width, canvas.height);

      drawBackground();
      drawResources();
      drawBuildings();
      drawAnimals();
      drawMonsters();
      drawPlayer();
      drawHUD();
    }

    function drawBackground() {
      const gradient = ctx.createLinearGradient(0, 0, 0, canvas.height);
      const dayRatio = state.isDay ? 1 - state.time / state.dayLength : 0;
      const nightRatio = state.isDay ? 0 : state.time / state.nightLength;
      const skyColor = blendColor("#0ea5e9", "#0f172a", nightRatio);
      const groundColor = blendColor("#14532d", "#1f2937", nightRatio);
      gradient.addColorStop(0, skyColor);
      gradient.addColorStop(1, groundColor);
      ctx.fillStyle = gradient;
      ctx.fillRect(0, 0, canvas.width, canvas.height);

      ctx.strokeStyle = "rgba(255,255,255,0.04)";
      for (let x = 0; x < COLS; x++) {
        for (let y = 0; y < ROWS; y++) {
          ctx.strokeRect(x * TILE, y * TILE, TILE, TILE);
        }
      }
    }

    function blendColor(colorA, colorB, t) {
      const a = hexToRgb(colorA);
      const b = hexToRgb(colorB);
      const r = Math.round(a.r + (b.r - a.r) * t);
      const g = Math.round(a.g + (b.g - a.g) * t);
      const bl = Math.round(a.b + (b.b - a.b) * t);
      return `rgb(${r},${g},${bl})`;
    }

    function hexToRgb(hex) {
      const bigint = parseInt(hex.replace("#", ""), 16);
      return {
        r: (bigint >> 16) & 255,
        g: (bigint >> 8) & 255,
        b: bigint & 255
      };
    }

    function drawEntity(x, y, color, size = 0.6) {
      ctx.fillStyle = color;
      ctx.beginPath();
      ctx.arc(x * TILE, y * TILE, (TILE * size) / 2, 0, Math.PI * 2);
      ctx.fill();
    }

    function drawPlayer() {
      const player = state.player;
      drawEntity(player.x, player.y, "#facc15", 0.7);
      ctx.strokeStyle = "#fbbf24";
      ctx.lineWidth = 2;
      ctx.strokeRect((player.x - 0.4) * TILE, (player.y - 0.4) * TILE, TILE * 0.8, TILE * 0.8);
    }

    function drawAnimals() {
      state.animals.forEach(animal => drawEntity(animal.x, animal.y, "#f97316"));
    }

    function drawMonsters() {
      state.monsters.forEach(monster => {
        drawEntity(monster.x, monster.y, "#ef4444", 0.7);
        ctx.fillStyle = "rgba(239,68,68,0.4)";
        ctx.fillRect((monster.x - 0.5) * TILE, (monster.y - 0.5) * TILE, TILE, TILE);
      });
    }

    function drawResources() {
      state.resources.forEach(res => {
        if (res.type === "tree") {
          ctx.fillStyle = "#22c55e";
          ctx.fillRect((res.x - 0.45) * TILE, (res.y - 0.45) * TILE, TILE * 0.9, TILE * 0.9);
        } else {
          ctx.fillStyle = "#94a3b8";
          ctx.beginPath();
          ctx.moveTo(res.x * TILE, (res.y - 0.5) * TILE);
          ctx.lineTo((res.x + 0.5) * TILE, (res.y + 0.5) * TILE);
          ctx.lineTo((res.x - 0.5) * TILE, (res.y + 0.5) * TILE);
          ctx.closePath();
          ctx.fill();
        }
      });
    }

    function drawBuildings() {
      state.buildings.forEach(b => {
        ctx.fillStyle = b.type === "woodWall" ? "#b45309" : "#64748b";
        ctx.fillRect((b.x - 0.5) * TILE, (b.y - 0.5) * TILE, TILE, TILE);
        ctx.strokeStyle = "rgba(15,23,42,0.4)";
        ctx.lineWidth = 2;
        ctx.strokeRect((b.x - 0.5) * TILE, (b.y - 0.5) * TILE, TILE, TILE);
      });
    }

    function drawHUD() {
      const player = state.player;
      const cycle = state.isDay ? "昼" : "夜";
      const cycleProgress = Math.round((state.time / (state.isDay ? state.dayLength : state.nightLength)) * 100);
      statusEl.innerHTML = `
        <strong>${cycle}</strong> ${cycleProgress}%<br>
        HP: ${"❤".repeat(player.hp)}${"♡".repeat(player.maxHp - player.hp)}<br>
        木材: ${player.inventory.wood} / 石材: ${player.inventory.stone} / 食料: ${player.inventory.food}
      `;

      if (!state.isDay) {
        ctx.fillStyle = "rgba(15,23,42,0.35)";
        ctx.fillRect(0, 0, canvas.width, canvas.height);
        ctx.fillStyle = "rgba(244, 63, 94, 0.15)";
        ctx.fillRect(0, 0, canvas.width, 60);
      }
    }

    let last = performance.now();
    function loop(now) {
      const dt = Math.min((now - last) / 1000, 0.05);
      last = now;
      if (state.player.hp > 0) {
        update(dt);
      }
      draw();
      requestAnimationFrame(loop);
    }

    initWorld();
    requestAnimationFrame(loop);
  </script>
</body>
</html>
