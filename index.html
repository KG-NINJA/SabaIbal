<!DOCTYPE html>
<html lang="ja">
<head>
  <meta charset="UTF-8">
  <title>ã‚¯ãƒ©ãƒ•ãƒˆã‚µãƒã‚¤ãƒãƒ« - HTML 2D</title>
  <style>
    :root {
      --day-sky: #8dd9ff;
      --night-sky: #0a0d2a;
      --ui-bg: rgba(20, 20, 20, 0.7);
      --ui-text: #f4f7ff;
      font-family: 'Segoe UI', 'Hiragino Kaku Gothic ProN', Meiryo, sans-serif;
    }

    body {
      margin: 0;
      min-height: 100vh;
      display: flex;
      align-items: center;
      justify-content: center;
      background: linear-gradient(180deg, var(--day-sky), #4caf50);
      transition: background 1s ease;
      color: #1c2733;
    }

    body.night {
      background: radial-gradient(circle at 50% 20%, #1a2755 0%, var(--night-sky) 100%);
      color: #e4ebff;
    }

    main {
      display: grid;
      gap: 16px;
      grid-template-columns: auto;
      justify-items: center;
      padding: 24px;
    }

    canvas {
      background: rgba(255, 255, 255, 0.15);
      box-shadow: 0 12px 32px rgba(0, 0, 0, 0.35);
      border-radius: 12px;
      image-rendering: pixelated;
      display: block;
    }

    .hud {
      width: 640px;
      display: grid;
      grid-template-columns: 1fr 1fr 1fr;
      gap: 16px;
      background: var(--ui-bg);
      color: var(--ui-text);
      padding: 12px 16px;
      border-radius: 12px;
      box-shadow: 0 10px 25px rgba(0, 0, 0, 0.25);
    }

    .hud section {
      min-width: 0;
    }

    .hud h2 {
      margin: 0 0 6px;
      font-size: 0.95rem;
      letter-spacing: 0.05em;
      text-transform: uppercase;
    }

    .hud p {
      margin: 4px 0;
      font-size: 0.85rem;
      line-height: 1.3;
    }

    .game-over {
      position: absolute;
      inset: 0;
      display: none;
      align-items: center;
      justify-content: center;
      backdrop-filter: blur(6px);
      background: rgba(0, 0, 0, 0.65);
      color: #fff;
      text-align: center;
      flex-direction: column;
      gap: 16px;
      z-index: 10;
    }

    .game-over.visible {
      display: flex;
    }

    .game-over h1 {
      margin: 0;
      font-size: 2.4rem;
      letter-spacing: 0.08em;
    }

    .game-over button {
      border: none;
      border-radius: 999px;
      padding: 12px 28px;
      font-size: 1.1rem;
      background: linear-gradient(135deg, #ff6d6d, #ff9a62);
      color: #fff;
      cursor: pointer;
      box-shadow: 0 8px 18px rgba(0, 0, 0, 0.4);
      transition: transform 0.2s ease, box-shadow 0.2s ease;
    }

    .game-over button:hover {
      transform: translateY(-2px);
      box-shadow: 0 12px 26px rgba(0, 0, 0, 0.4);
    }

    footer {
      font-size: 0.85rem;
      text-align: center;
      color: inherit;
    }
  </style>
</head>
<body>
  <main>
    <canvas id="game" width="640" height="480"></canvas>
    <div class="hud" id="hud">
      <section>
        <h2>ç”Ÿå­˜æƒ…å ±</h2>
        <p id="time">æ™‚é–“: æ˜¼</p>
        <p id="cycle">æ—¥æ•°: 1</p>
        <p id="health">ä½“åŠ›: 100</p>
      </section>
      <section>
        <h2>ã‚¤ãƒ³ãƒ™ãƒ³ãƒˆãƒª</h2>
        <p id="inventory">æœ¨æ:0 çŸ³æ:0 è‚‰:0</p>
      </section>
      <section>
        <h2>æ“ä½œèª¬æ˜</h2>
        <p>WASD / çŸ¢å°: ç§»å‹•</p>
        <p>Space: æ¡å–ãƒ»æ”»æ’ƒ</p>
        <p>B: å£ã‚’å»ºç¯‰</p>
        <p style="margin-top: 8px; color: #ffeb3b;">ğŸ„ ã‚­ãƒã‚³: 8ç§’ç„¡æ•µ</p>
      </section>
    </div>
    <footer>
      æ˜¼ã¯ç´ æé›†ã‚ã¨ç‹©ã‚Šã§æº–å‚™ã‚’æ•´ãˆã€å¤œã¯å»ºç¯‰ã—ãŸé˜²å£ã§æ€ªç‰©ã‹ã‚‰èº«ã‚’å®ˆã‚ã†ï¼
    </footer>
  </main>

  <div class="game-over" id="gameOver">
    <h1>Game Over</h1>
    <p id="result"></p>
    <button id="retry">ã‚‚ã†ä¸€åº¦æŒ‘æˆ¦</button>
  </div>

  <script>
    const canvas = document.getElementById('game');
    const ctx = canvas.getContext('2d');

    const TILE_SIZE = 32;
    const GRID_WIDTH = canvas.width / TILE_SIZE;
    const GRID_HEIGHT = canvas.height / TILE_SIZE;

    const COLORS = {
      grass: '#5cb85c',
      forest: '#387c38',
      stone: '#bfbfbf',
      wall: '#8b5a2b',
      animal: '#f2d388',
      monster: '#ba2d2d',
      player: '#fffb91',
      mushroom: '#ff6b9d'
    };

    const animals = [];
    const monsters = [];
    const walls = [];
    const resourceNodes = [];
    const mushrooms = [];

    let inputs = new Set();
    let lastInteraction = 0;
    let lastBuildTime = 0;
    let monsterMoveCounter = 0;
    let playerMoveCounter = 0;
    let monsterAttackCounter = 0;
    let lastPlayerFacingDir = { x: 1, y: 0 };
    let invincibleUntil = 0;

    const player = {
      x: Math.floor(GRID_WIDTH / 2),
      y: Math.floor(GRID_HEIGHT / 2),
      health: 100,
      wood: 0,
      stone: 0,
      meat: 0
    };

    const DAY_LENGTH = 120 * 1000;
    let elapsed = 0;
    let lastTimestamp = 0;
    let dayCount = 1;
    let gameOver = false;

    const hudTime = document.getElementById('time');
    const hudCycle = document.getElementById('cycle');
    const hudHealth = document.getElementById('health');
    const hudInventory = document.getElementById('inventory');
    const gameOverView = document.getElementById('gameOver');
    const result = document.getElementById('result');
    const retry = document.getElementById('retry');

    retry.addEventListener('click', () => {
      window.location.reload();
    });

    function initWorld() {
      for (let i = 0; i < 40; i++) {
        placeResource('tree');
      }
      for (let i = 0; i < 25; i++) {
        placeResource('stone');
      }
    }

    function placeResource(type) {
      let placed = false;
      let attempts = 0;
      while (!placed && attempts < 200) {
        attempts++;
        const x = Math.floor(Math.random() * GRID_WIDTH);
        const y = Math.floor(Math.random() * GRID_HEIGHT);
        if (!isBlocked(x, y)) {
          resourceNodes.push({ x, y, type, life: type === 'tree' ? 3 : 4 });
          placed = true;
        }
      }
    }

    function spawnAnimal() {
      const options = getEdgeTiles();
      if (!options.length) return;
      const spot = options[Math.floor(Math.random() * options.length)];
      animals.push({ ...spot, hp: 2, cooldown: 0 });
    }

    function spawnMonster() {
      const options = getEdgeTiles();
      if (!options.length) return;
      const spot = options[Math.floor(Math.random() * options.length)];
      monsters.push({ ...spot, hp: 3 });
    }

    function spawnMushroom() {
      const x = Math.floor(Math.random() * GRID_WIDTH);
      const y = Math.floor(Math.random() * GRID_HEIGHT);
      if (!isBlocked(x, y)) {
        mushrooms.push({ x, y });
      }
    }

    function getEdgeTiles() {
      const edgeTiles = [];
      for (let x = 0; x < GRID_WIDTH; x++) {
        edgeTiles.push({ x, y: 0 });
        edgeTiles.push({ x, y: GRID_HEIGHT - 1 });
      }
      for (let y = 1; y < GRID_HEIGHT - 1; y++) {
        edgeTiles.push({ x: 0, y });
        edgeTiles.push({ x: GRID_WIDTH - 1, y });
      }
      return edgeTiles.filter(tile => !isBlocked(tile.x, tile.y));
    }

    function isBlocked(x, y) {
      if (x < 0 || y < 0 || x >= GRID_WIDTH || y >= GRID_HEIGHT) return true;
      if (walls.some(w => w.x === x && w.y === y)) return true;
      return resourceNodes.some(node => node.x === x && node.y === y && node.life > 0);
    }

    function isNight() {
      const cycle = (elapsed % DAY_LENGTH) / DAY_LENGTH;
      return cycle >= 0.5;
    }

    function update(dt) {
      if (gameOver) return;

      elapsed += dt;
      const cycle = (elapsed % DAY_LENGTH) / DAY_LENGTH;

      if (cycle < 0.5) {
        document.body.classList.remove('night');
        if (animals.length < 4 && Math.random() < 0.005) {
          spawnAnimal();
        }
        monsters.length = 0;
      } else {
        document.body.classList.add('night');
        if (Math.random() < 0.008 && monsters.length < 6) {
          spawnMonster();
        }
      }

      if (elapsed >= DAY_LENGTH * dayCount) {
        dayCount++;
      }

      if (Math.random() < 0.001 && mushrooms.length < 3) {
        spawnMushroom();
      }

      movePlayer();
      moveAnimals(dt);
      moveMonsters(dt);
      handleCombat();
      updateHUD(cycle);
    }

    function movePlayer() {
      playerMoveCounter++;
      if (playerMoveCounter < 8) return;
      playerMoveCounter = 0;

      let dx = 0, dy = 0;
      if (inputs.has('ArrowUp') || inputs.has('KeyW')) dy--;
      if (inputs.has('ArrowDown') || inputs.has('KeyS')) dy++;
      if (inputs.has('ArrowLeft') || inputs.has('KeyA')) dx--;
      if (inputs.has('ArrowRight') || inputs.has('KeyD')) dx++;

      if (dx !== 0 || dy !== 0) {
        lastPlayerFacingDir = { x: dx, y: dy };
        const nx = player.x + dx;
        const ny = player.y + dy;
        if (!isSolid(nx, ny)) {
          player.x = nx;
          player.y = ny;
        }
      }
    }

    function isSolid(x, y) {
      if (x < 0 || y < 0 || x >= GRID_WIDTH || y >= GRID_HEIGHT) return true;
      if (walls.some(w => w.x === x && w.y === y)) return true;
      return false;
    }

    function moveAnimals(dt) {
      animals.forEach(animal => {
        animal.cooldown -= dt;
        if (animal.cooldown <= 0) {
          animal.cooldown = 2000 + Math.random() * 3000;
          const dir = [[1,0],[-1,0],[0,1],[0,-1]][Math.floor(Math.random() * 4)];
          const nx = animal.x + dir[0];
          const ny = animal.y + dir[1];
          if (!isSolid(nx, ny)) {
            animal.x = Math.max(0, Math.min(GRID_WIDTH - 1, nx));
            animal.y = Math.max(0, Math.min(GRID_HEIGHT - 1, ny));
          }
        }
      });
    }

    function moveMonsters(dt) {
      monsterMoveCounter++;
      monsterAttackCounter++;
      
      if (monsterMoveCounter >= 6) {
        monsterMoveCounter = 0;
        
        monsters.forEach(monster => {
          const dx = Math.sign(player.x - monster.x);
          const dy = Math.sign(player.y - monster.y);
          const nx = monster.x + dx;
          const ny = monster.y + dy;

          if (!isSolid(nx, ny)) {
            monster.x = nx;
            monster.y = ny;
          }
        });
      }

      if (monsterAttackCounter >= 5) {
        monsterAttackCounter = 0;
        
        monsters.forEach(monster => {
          if (monster.x === player.x && monster.y === player.y) {
            const now = performance.now();
            if (now < invincibleUntil) {
              monster.hp -= 1;
              if (monster.hp <= 0) {
                monsters.splice(monsters.indexOf(monster), 1);
              }
            } else {
              player.health -= 5;
              if (player.health <= 0) {
                triggerGameOver();
              }
            }
          }
        });
      }
    }

    function handleCombat() {
      if (!inputs.has('Space')) return;
      const now = performance.now();
      if (now - lastInteraction < 250) return;
      lastInteraction = now;

      const nodes = resourceNodes.filter(node => node.life > 0 && distance(node, player) <= 1);
      if (nodes.length) {
        nodes[0].life -= 1;
        if (nodes[0].type === 'tree') {
          player.wood += 1;
        } else {
          player.stone += 1;
        }
        return;
      }

      const mushroom = mushrooms.find(m => distance(m, player) <= 1);
      if (mushroom) {
        invincibleUntil = now + 8000;
        mushrooms.splice(mushrooms.indexOf(mushroom), 1);
        return;
      }

      const targetWall = walls.find(wall => distance(wall, player) <= 1);
      if (targetWall) {
        walls.splice(walls.indexOf(targetWall), 1);
        return;
      }

      const targetAnimal = animals.find(animal => distance(animal, player) <= 1);
      if (targetAnimal) {
        targetAnimal.hp -= 1;
        if (targetAnimal.hp <= 0) {
          player.meat += 1;
          animals.splice(animals.indexOf(targetAnimal), 1);
        }
        return;
      }

      const targetMonster = monsters.find(monster => distance(monster, player) <= 1);
      if (targetMonster) {
        targetMonster.hp -= 1;
        if (targetMonster.hp <= 0) {
          monsters.splice(monsters.indexOf(targetMonster), 1);
        }
      }
    }

    function buildWall() {
      if (player.wood < 1) return;
      const now = performance.now();
      if (now - lastBuildTime < 150) return;
      lastBuildTime = now;

      const target = {
        x: player.x + lastPlayerFacingDir.x,
        y: player.y + lastPlayerFacingDir.y
      };
      
      if (isSolid(target.x, target.y)) return;
      player.wood -= 1;
      walls.push(target);
    }

    function distance(a, b) {
      return Math.max(Math.abs(a.x - b.x), Math.abs(a.y - b.y));
    }

    function draw() {
      ctx.clearRect(0, 0, canvas.width, canvas.height);

      for (let y = 0; y < GRID_HEIGHT; y++) {
        for (let x = 0; x < GRID_WIDTH; x++) {
          ctx.fillStyle = COLORS.grass;
          ctx.fillRect(x * TILE_SIZE, y * TILE_SIZE, TILE_SIZE, TILE_SIZE);
        }
      }

      if (isNight()) {
        ctx.fillStyle = 'rgba(10, 13, 42, 0.5)';
        ctx.fillRect(0, 0, canvas.width, canvas.height);
      }

      resourceNodes.forEach(node => {
        if (node.life <= 0) return;
        ctx.fillStyle = node.type === 'tree' ? '#387c38' : '#bfbfbf';
        ctx.beginPath();
        ctx.roundRect(node.x * TILE_SIZE + 4, node.y * TILE_SIZE + 4, TILE_SIZE - 8, TILE_SIZE - 8, 6);
        ctx.fill();
      });

      walls.forEach(wall => {
        ctx.fillStyle = COLORS.wall;
        ctx.fillRect(wall.x * TILE_SIZE + 6, wall.y * TILE_SIZE + 6, TILE_SIZE - 12, TILE_SIZE - 12);
      });

      animals.forEach(animal => {
        ctx.fillStyle = COLORS.animal;
        ctx.beginPath();
        ctx.arc(animal.x * TILE_SIZE + TILE_SIZE / 2, animal.y * TILE_SIZE + TILE_SIZE / 2, TILE_SIZE / 3, 0, Math.PI * 2);
        ctx.fill();
      });

      monsters.forEach(monster => {
        ctx.fillStyle = COLORS.monster;
        ctx.fillRect(monster.x * TILE_SIZE + 4, monster.y * TILE_SIZE + 4, TILE_SIZE - 8, TILE_SIZE - 8);
      });

      mushrooms.forEach(mushroom => {
        ctx.fillStyle = COLORS.mushroom;
        ctx.beginPath();
        ctx.arc(mushroom.x * TILE_SIZE + TILE_SIZE / 2, mushroom.y * TILE_SIZE + TILE_SIZE / 2, TILE_SIZE / 3.5, 0, Math.PI * 2);
        ctx.fill();
      });

      ctx.fillStyle = COLORS.player;
      ctx.beginPath();
      ctx.arc(player.x * TILE_SIZE + TILE_SIZE / 2, player.y * TILE_SIZE + TILE_SIZE / 2, TILE_SIZE / 2.5, 0, Math.PI * 2);
      ctx.fill();

      const now = performance.now();
      if (now < invincibleUntil) {
        ctx.fillStyle = 'rgba(255, 215, 0, 0.4)';
        ctx.beginPath();
        ctx.arc(player.x * TILE_SIZE + TILE_SIZE / 2, player.y * TILE_SIZE + TILE_SIZE / 2, TILE_SIZE / 2, 0, Math.PI * 2);
        ctx.fill();
        
        const remaining = Math.ceil((invincibleUntil - now) / 1000);
        ctx.fillStyle = '#ffeb3b';
        ctx.font = 'bold 14px Arial';
        ctx.textAlign = 'center';
        ctx.fillText(remaining + 's', player.x * TILE_SIZE + TILE_SIZE / 2, player.y * TILE_SIZE - 14);
      }

      requestAnimationFrame(draw);
    }

    function updateHUD(cycle) {
      const dayPhase = cycle < 0.5 ? 'æ˜¼' : 'å¤œ';
      hudTime.textContent = `æ™‚é–“: ${dayPhase}`;
      hudCycle.textContent = `æ—¥æ•°: ${dayCount}`;
      hudHealth.textContent = `ä½“åŠ›: ${player.health}`;
      hudInventory.textContent = `æœ¨æ:${player.wood} çŸ³æ:${player.stone} è‚‰:${player.meat}`;
    }

    function triggerGameOver() {
      gameOver = true;
      result.textContent = `${dayCount} æ—¥ç›®ã§å€’ã‚Œã¾ã—ãŸã€‚ã‚‚ã†ä¸€åº¦æŒ‘æˆ¦ã—ã¾ã™ã‹ï¼Ÿ`;
      gameOverView.classList.add('visible');
    }

    document.addEventListener('keydown', (event) => {
      inputs.add(event.code);
      if (event.code === 'Space') {
        event.preventDefault();
      }
      if (event.code === 'KeyB') {
        buildWall();
      }
    });

    document.addEventListener('keyup', (event) => {
      inputs.delete(event.code);
    });

    function gameLoop(timestamp) {
      if (!lastTimestamp) lastTimestamp = timestamp;
      const dt = timestamp - lastTimestamp;
      lastTimestamp = timestamp;
      update(dt);
      if (!gameOver) {
        requestAnimationFrame(gameLoop);
      }
    }

    initWorld();
    requestAnimationFrame(draw);
    requestAnimationFrame(gameLoop);
  </script>
</body>
</html>
